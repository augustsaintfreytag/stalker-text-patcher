-- Logging

local function log(...)
	printf(...)
end

-- Entry Point

function on_xml_read()
	log("Loading Saint's DXML UI text patcher.")

	RegisterScriptCallback("on_xml_read", function(xml_scope_name, xml_obj)
		-- Modules

		local config = config_ui_text_patcher
		local blacklist = map_blacklist_from_table(config.ui_file_blacklist)
		local file_name = file_name_from_scope_name(xml_scope_name)

		-- Prevalidation

		if blacklist[file_name] or not string.find(xml_scope_name, "st_") then
			return
		end

		-- Processing

		log("DXML UI string patcher processing file '%s' (scope '%s').", file_name, xml_scope_name)

		process_capitalization_elements(file_name, xml_obj, config.ui_string_element_capitalization_patterns)
		process_menu_elements(file_name, xml_obj, config.ui_menu_string_element_patterns)
		process_substitution_elements(file_name, config.ui_string_element_substitution_values, xml_obj)
	end)
end

-- Process: Capitalized Elements

function process_capitalization_elements(file_name, xml_obj, patterns)
	for_each_text_element_in_object(file_name, xml_obj, function(id, _)
		return patterns_contain_id(patterns, id)
	end, function(id, text_element, text)
		log("DXML UI text patcher processing file '%s', element id '%s', writing capitalized text.", file_name, id)
		local formatted_text = saint_utils.capitalize_words(text)
		xml_obj:setText(text_element, formatted_text)
	end)
end

-- Process: Menu Elements

function process_menu_elements(file_name, xml_obj, patterns)
	for_each_text_element_in_object(file_name, xml_obj, function(id, _)
		return patterns_contain_id(patterns, id)
	end, function(id, text_element, text)
		log("DXML UI text patcher processing file '%s', element id '%s', writing menu text.", file_name, id)
		local formatted_text = string.lower(text)
		xml_obj:setText(text_element, formatted_text)
	end)
end

-- Process: Substitution Elements

function process_substitution_elements(file_name, substitution_values, xml_obj)
	local substitution_table = substitution_values[file_name]

	if substitution_table then
		for match_id, substitution_text in pairs(substitution_table) do
			local string_element = xml_obj:query("string[id=" .. match_id .. "]")[1]

			if not string_element then
				goto continue
			end

			with_text_element_from_string_element(xml_obj, string_element, function(text_element, _)
				xml_obj:setText(text_element, substitution_text)
			end)

			::continue::
		end
	end
end

-- Iteration & Extraction

-- Iterates through all `<string>` elements in the given XML object.
-- Extracts the element's `id` attribute, calls the given `predicate` block to
-- determine elements to be processed. Calls the given `callback` block for all
-- remaining text elements.
function for_each_text_element_in_object(file_name, xml_obj, predicate, callback)
	local string_elements = xml_obj:query("string")

	if not string_elements or #string_elements == 0 then
		log("DXML UI text patcher did not find any string elements in file '%s'.", file_name)
		return
	end

	local filtered_text_elements = table.filter(string_elements, function(string_element)
		local id = (xml_obj:getElementAttr(string_element) or {})["id"]
		return predicate(id, string_element)
	end)

	if #filtered_text_elements == 0 then
		return
	end

	log("DXML UI text patcher found %s string elements (filtered from %s) in file '%s'.", #filtered_text_elements,
		#string_elements, file_name)

	for _, string_element in ipairs(filtered_text_elements) do
		with_text_element_from_string_element(xml_obj, string_element, function(text_element, text)
			callback(id, text_element, text)
		end)
	end
end

-- Extracts the child text element and contained text value and calls the given callback
-- with {element, text} if found. The callback is not invoked when no text element is found.
function with_text_element_from_string_element(xml_obj, string_element, callback)
	local id = (xml_obj:getElementAttr(string_element) or {})["id"]
	local text_element = xml_obj:query("string[id=" .. id .. "] > text")[1]

	if not text_element then
		return nil
	end

	local text = xml_obj:getText(text_element)

	return callback(text_element, text)
end

-- General Utility

-- Return extracted XML module name without path or file extension from scope name.
-- Example input: "ui\ui_mm_main.xml", output: "ui_mm_main"
function file_name_from_scope_name(scope_name)
	local index_of_last_path_separator = string.find(scope_name, "\\[^\\]*$")
	local file_name_with_extension = string.sub(scope_name, index_of_last_path_separator + 1)
	local index_of_extension_separator = string.find(file_name_with_extension, "%.[^%.]*$")
	local file_name = string.sub(file_name_with_extension, 1, index_of_extension_separator - 1)

	return file_name
end

-- Predicate function to check if any of the given patterns match the given id.
function patterns_contain_id(patterns, id)
	for _, pattern in ipairs(patterns) do
		if string.find(id, pattern) then
			return true
		end
	end

	return false
end

-- Create an access-optimized Set-like blacklist table to exclude files from processing.
function map_blacklist_from_table(table_value)
	local blacklist = {}

	for _, value in ipairs(table_value) do
		blacklist[value] = true
	end

	return blacklist
end

-- Type Extensions

table.filter = function(table_value, predicate)
	local out = {}

	for _, v in ipairs(table_value) do
		if predicate(v) then
			table.insert(out, v)
		end
	end

	return out
end
