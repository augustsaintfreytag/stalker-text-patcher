-- Logging

local function log(...)
	printf(...)
end

-- Entry Point

function on_xml_read()
	log("Loading Saint's DXML UI text patcher.")

	RegisterScriptCallback("on_xml_read", function(xml_scope_name, xml_obj)
		-- Modules

		local config = config_ui_text_patcher
		local blacklist = map_blacklist_from_table(config.ui_file_blacklist)
		local file_name = file_name_from_scope_name(xml_scope_name)

		-- Prevalidation

		if blacklist[file_name] or not string.find(xml_scope_name, "st_") then
			-- log("DXML UI string patcher skipping file '%s'.", xml_scope_name)
			return
		end

		-- Processing

		log("DXML UI string patcher processing file '%s' (scope '%s').", file_name, xml_scope_name)

		process_capitalization_elements(file_name, xml_obj, config.ui_string_element_capitalization_queries)
		process_menu_elements(file_name, xml_obj, config.ui_menu_string_element_queries)
		process_substitution_elements(file_name, config.ui_string_element_substitution_values, xml_obj)
	end)
end

function process_capitalization_elements(file_name, xml_obj, queries)
	for _, query in ipairs(queries) do
		for_each_text_element_in_query(file_name, xml_obj, query, function(id, text)
			log("DXML UI text patcher processing file '%s', element id '%s', writing capitalized text.", file_name,
				id)
			return saint_utils.capitalize_words(text)
		end)
	end
end

function process_menu_elements(file_name, xml_obj, queries)
	for _, query in ipairs(queries) do
		for_each_text_element_in_query(file_name, xml_obj, query, function(id, text)
			log("DXML UI text patcher processing file '%s', element id '%s', writing lowercase menu text.", file_name,
				id)
			return string.lower(text)
		end)
	end
end

function process_substitution_elements(file_name, substitution_values, xml_obj)
	local substitution_table = substitution_values[file_name]

	if substitution_table then
		for match_id, substitution_text in pairs(substitution_table) do
			local string_element = xml_obj:query("string[id=" .. match_id .. "]")[1]

			if not string_element then
				goto continue
			end

			with_text_element_from_string_element(xml_obj, string_element, function(text_element, _)
				xml_obj:setText(text_element, substitution_text)
			end)

			::continue::
		end
	end
end

-- General Utility

-- Return extracted XML module name without path or file extension from scope name.
-- Example input: "ui\ui_mm_main.xml", output: "ui_mm_main"
function file_name_from_scope_name(scope_name)
	local index_of_last_path_separator = string.find(scope_name, "\\[^\\]*$")
	local file_name_with_extension = string.sub(scope_name, index_of_last_path_separator + 1)
	local index_of_extension_separator = string.find(file_name_with_extension, "%.[^%.]*$")
	local file_name = string.sub(file_name_with_extension, 1, index_of_extension_separator - 1)

	return file_name
end

-- Create an access-optimized Set-like blacklist table to exclude files from processing.
function map_blacklist_from_table(blacklist_table)
	local blacklist = {}

	for _, value in ipairs(blacklist_table) do
		blacklist[value] = true
	end

	return blacklist
end

-- Iteration & Extraction

-- Iterates over all text elements, matching the given query, and calls the given callback.
function for_each_text_element_in_query(file_name, xml_obj, query, callback)
	local string_elements = xml_obj:query(query)

	if not string_elements or #string_elements == 0 then
		log("DXML UI text patcher did not find any elements for query '%s' in file '%s'.", query, file_name)
		return
	end

	log("DXML UI text patcher found %s elements matching query '%s' in file '%s'.", #string_elements, query, file_name)

	for _, string_element in ipairs(string_elements) do
		with_text_element_from_string_element(xml_obj, string_element, function(text_element, text)
			local returned_text = callback(id, text)
			xml_obj:setText(text_element, returned_text)
		end)
	end
end

-- Extracts the child text element and contained text value and calls the given callback
-- with {element, text} if found. The callback is not invoked when no text element is found.
function with_text_element_from_string_element(xml_obj, string_element, callback)
	local id = (xml_obj:getElementAttr(string_element) or {})["id"]
	local text_element = xml_obj:query("string[id=" .. id .. "] > text")[1]
	-- local text_element = string_element:query("text")[1]

	if not text_element then
		return nil
	end

	local text = xml_obj:getText(text_element)

	return callback(text_element, text)
end
